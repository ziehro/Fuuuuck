// lib/services/beach_data_service.dart
import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:fuuuuck/models/beach_model.dart';
import 'package:fuuuuck/models/contribution_model.dart';
import 'package:uuid/uuid.dart'; // For generating unique IDs for files

class BeachDataService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final Uuid _uuid = const Uuid(); // Instantiate Uuid for generating v4 IDs

  // --- Helper: Upload Image to Firebase Storage ---
  /// Uploads an image file to Firebase Storage and returns its download URL.
  Future<String?> uploadImage(File imageFile) async {
    try {
      final String fileName = 'beach_images/${_uuid.v4()}.jpg'; // Unique filename
      final Reference storageRef = _storage.ref().child(fileName);
      final UploadTask uploadTask = storageRef.putFile(imageFile);

      final TaskSnapshot snapshot = await uploadTask;
      final String downloadUrl = await snapshot.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      print('Error uploading image: $e'); // Use print for errors in services for now
      return null;
    }
  }

  // --- Add a New Beach and its First Contribution ---
  /// Creates a new beach document and its initial contribution.
  /// Returns the ID of the newly created beach.
  Future<String?> addBeach({
    required Beach initialBeach,
    required Contribution initialContribution,
  }) async {
    try {
      // 1. Create the main beach document
      // Note: We don't use initialBeach.id here as it's generated by Firestore on .add()
      final DocumentReference beachDocRef = await _firestore.collection('beaches').add(initialBeach.toMap());

      // 2. Add the initial contribution to its subcollection
      final DocumentReference contributionDocRef = await beachDocRef.collection('contributions').add(initialContribution.toMap());

      print('New Beach added with ID: ${beachDocRef.id}');
      print('Initial Contribution added with ID: ${contributionDocRef.id}');

      // In a real scenario, you'd trigger your Cloud Function here if not already
      // configured to listen for new 'contributions' directly.

      return beachDocRef.id;
    } catch (e) {
      print('Error adding new beach: $e');
      return null;
    }
  }

  // --- Add a Contribution to an Existing Beach ---
  /// Adds a new contribution document to an existing beach's subcollection.
  /// This will typically be called when a user adds data to an already existing beach.
  Future<void> addContribution({
    required String beachId,
    required Contribution contribution,
  }) async {
    try {
      // Get the reference to the specific beach
      final DocumentReference beachDocRef = _firestore.collection('beaches').doc(beachId);

      // Add the new contribution to its 'contributions' subcollection
      await beachDocRef.collection('contributions').add(contribution.toMap());
      print('Contribution added for beach ID: $beachId');

      // The Cloud Function should be listening for new contributions in this subcollection
      // to trigger the amalgamation process on the main beach document.
    } catch (e) {
      print('Error adding contribution: $e');
      rethrow; // Re-throw for UI to handle if needed
    }
  }

  // --- Get All Beaches (for Map Display) ---
  /// Provides a stream of all beach documents, useful for real-time map updates.
  Stream<List<Beach>> getBeaches() {
    return _firestore.collection('beaches').snapshots().map((snapshot) {
      return snapshot.docs.map((doc) => Beach.fromFirestore(doc)).toList();
    });
  }

  // --- Get a Specific Beach by ID (for Detail Screen) ---
  /// Fetches a single beach document by its ID.
  Future<Beach?> getBeachById(String beachId) async {
    try {
      final DocumentSnapshot doc = await _firestore.collection('beaches').doc(beachId).get();
      if (doc.exists) {
        return Beach.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      print('Error getting beach by ID $beachId: $e');
      return null;
    }
  }

// TODO: Implement getBeachesInArea(GeoPoint center, double radius) for map filtering later
// This would require more advanced Firestore queries or GeoHashing techniques.
}